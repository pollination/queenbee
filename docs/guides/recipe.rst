Create A New Recipe
===================

In this section we will walk you through how to create a new Recipe.

..  warning::
    This section is not complete yet. Please refer to the
    `Recipe Schema </schemas/recipes.html>`_ section for now.

Getting Started
---------------

A Recipe defines a set of Tasks which are combined in a directed acyclic
graph (DAG). The edges of this graph correspond to the path that an input takes
to a Task. The outputs of a Task can be passed as inputs to subsequent Tasks.
As the graph is acyclic, a Task may not pass its output to any Task
that is at an equal or earlier stage in the Recipe.

This graph can be thought of as a program's `call graph <https://en.wikipedia.org/wiki/Call_graph>`_, but one that can call functions
written in arbitrary languages executed on an arbitrary runtime rather than simply being executed by ``python`` or ``node`` or compiled into an ELF and run on a compatible OS.

As such, the outputs of one Task that are sent to another Task can be thought of as a kind
of file-based inter-process communication. Provided that the first Task can output a filetype
that the second Task can parse, the implementation is of no concern. At least, at the level of a Recipe.

Finally, it is important to note that a Task in a Recipe could be another
DAG made of many individual Tasks. Thus, graphs can be nested inside one another
to isolate arbitrary levels of complexity in a manageable way.

Similar to the plugin creation documentation, the first step is to use
``queenbee`` to create a recipe scaffold:

.. code-block:: console
    $ queenbee recipe new my-recipe

This will create a directory ``my-recipe`` in your current working directory.

Folder Structure
----------------

The structure of the created folder should look something like this::

    my-recipe
    ├── flow
    │   └── main.yaml
    ├── dependencies.yaml
    ├── LICENSE
    ├── package.yaml
    └── README.md

Metadata Configuration
----------------------

The recipe's metadata is defined by the ``package.yaml`` file. It is composed
of a ``MetaData`` type with multiple nullable fields. If you are familiar with
the ``npm`` ecosystem, you can think of this as an analogue to the
non-executable fields of ``package.json`` such as ``name``, ``version``,
``description``, etc.

* **annotations**: A dictionary of arbitrary (key, value) pairs that can be
  consumed by consumers of the recipe.
* **name**: The name of the recipe.
* **tag**: The tag of the recipe.
* **app_version**: The version of the application.
* **keywords**: A list of strings that are related to the package.
* **maintainers**: A list of ``Maintainer`` objects that describe the contact
  information of the people responsible for the recipe (you, in this case).
* **home**: ?
* **sources**: ?
* **icon**: A publicly-accessible URI to give the recipe a friendly face.
* **deprecated**: Whether or not the recipe is in active development.
* **description**: A textual description, analogous to a README.
* **license**: A valid `SPDX Identifier <https://spdx.org/licenses/>`_ which
  corresponds to the text in the ``LICENSE`` file.

Dependencies
------------

The dependencies are specified in the ``dependencies.yaml`` file. Each entry in
the ``dependencies`` array should point to a valid, packaged Plugin at a local
path (such as the result from the ``Create a New Recipe`` documentation) or
hosted on a publicly-available package server.

We can add a dependency that will be used in the Recipe by pulling from a public repo
by replacing the content of the autogenerated ``dependencies.yaml`` with the
following snippet:

.. code-block:: yaml

  dependencies:
  - type: Dependency
    annotations: {}
    kind: plugin
    name: honeybee-radiance
    hash: null
    alias: null
    tag: 0.4.1
    source: file://<absolute path>/energy-plus-0.1.0.tgz

This will add a reference to the ``honeybee-radiance`` Plugin, version ``0.4.1``
which is cloud-hosted on Pollination's registry server. This will allow us to use
Functions which are defined in this Plugin as the implementation that does the work
inside Tasks which are stitched together in the Recipe.

Flow
----

The ``flow/`` directory contains the YAML definitions of the DAGs of the recipe
as YAML files. At a minimum, the directory must contain a ``main.yaml`` which
is, surprisingly, the main graph.

DAG Tasks
---------

As mentioned above, a Task can itself be a DAG. This both allows complex graphs
to be reused inside other graphs and allows isolating related Tasks into a logical unit.

Add a new file at the path ``flow/dag.yaml``. Inside that file, place the following snippet:

.. code-block:: yaml

  type: DAG

This file ties three key concepts together. The files itself defines that it is
of ``type: DAG`` and has a ``tasks`` array of Task objects. The single Task
that we define uses the function ``daylight-coefficient`` from the
``honeybee-radiance`` Plugin that is defined in ``dependencies.yaml``.

Referencing Outputs to Inputs
-----------------------------

In order to pass outputs of one Task as inputs to another Task, it is necessary
to create an edge in the DAG that represents this connection.

.. code-block:: yaml

  - type: DAGTask
    annotations: {}
    name: create-octree
    template: honeybee-radiance/create-octree
    needs:
    - create-rad-folder
    arguments:
    - type: TaskPathArgument
      annotations: {}
      name: model
      from:
        type: TaskFolderReference
        annotations: {}
        name: create-rad-folder
        variable: model-folder
      sub_path: null
    loop: null
    sub_folder: null
    returns:
    - type: TaskPathReturn
      annotations: {}
      name: scene-file
      description: null
      path: resources/scene.oct
      required: true

This snippet specifies the ``create-octree`` Task and that it must come after ``create-rad-folder`` Task, as it is in the ``needs`` array. The link between the two tasks happens in the first element of the ``arguments`` array. Here, the only argument that the ``create-octree`` command needs is a path from another Task. The ``TaskPathArgument`` object specifies a ``from`` field that looks for a Task named ``create-rad-folder`` and acquires the value of its output that is named ``model-folder``.

The Task that supplies this source as an output can be defined by this snippet:

.. code-block:: yaml

  - type: DAGTask
    annotations: {}
    name: create-rad-folder
    template: honeybee-radiance/create-radiance-folder
    needs: []
    arguments:
    - type: TaskPathArgument
      annotations: {}
      name: input-model
      from:
        type: InputFileReference
        annotations: {}
        variable: model
      sub_path: null
    loop: null
    sub_folder: null
    returns:
    - type: TaskPathReturn
      annotations: {}
      name: model-folder
      description: null
      path: model
      required: true
    - type: TaskReturn
      annotations: {}
      name: sensor-grids
      description: Sensor grids information.

This defines a Task with an empty ``needs`` array. Note that, even though this
Task doesn't need another _Task_, it does still require an input ``TaskPathArgument`` named ``input-model``. Thus, this Task can be thought of as root node of the graph, but one that is still able to vary over the range of its input type. In this case, that type is a filesystem path.

Because this Task supplies an output, it can be used as the input to the ``create-octree`` task. In this case, the reference in ``create-octree`` points
to the first element of ``create-rad-folder``'s ``returns`` array.

Artifact Path Context Resolution
--------------------------------

?

Working With Loops
------------------

?
